# docker-compose.naissance.yml
version: '3.8'

networks:
  blockchain-network:
    external: true

volumes:
  ganache-data:
    driver: local

services:
  # Ganache CLI for local Ethereum blockchain
  ganache:
    image: trufflesuite/ganache-cli:latest
    container_name: ganache-blockchain
    ports:
      - "8545:8545"
    command: >
      --host 0.0.0.0
      --port 8545
      --networkId 1337
      --gasLimit 10000000
      --gasPrice 20000000000
      --accounts 10
      --ether 100
      --deterministic
      --mnemonic "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat"
    volumes:
      - ganache-data:/ganache_data
    networks:
      - blockchain-network
    restart: unless-stopped

  # Naissance Service
  naissance-service:
    build:
      context: ./services/naissance
      dockerfile: Dockerfile
    container_name: naissance-service
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - PORT=3001
      - ETHEREUM_PROVIDER=ws://ganache:8545
      - CONTRACT_ADDRESS=${CONTRACT_ADDRESS}
      - LOG_LEVEL=info
      - ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3002
    volumes:
      - ./services/naissance:/app
      - ./logs:/app/logs
    depends_on:
      - ganache
    networks:
      - blockchain-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

---

# Dockerfile for Naissance Service
# services/naissance/Dockerfile
FROM node:18-alpine

WORKDIR /app

# Install system dependencies
RUN apk add --no-cache \
    curl \
    python3 \
    make \
    g++

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Create logs directory
RUN mkdir -p logs

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Change ownership
RUN chown -R nodejs:nodejs /app

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3001

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3001/health || exit 1

# Start the application
CMD ["node", "index.js"]

---

# services/naissance/package.json
{
  "name": "naissance-service",
  "version": "1.0.0",
  "description": "Birth Certificate Management Service using Blockchain",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint .",
    "deploy-contract": "node scripts/deploy-contract.js",
    "setup": "npm run deploy-contract"
  },
  "dependencies": {
    "express": "^4.18.2",
    "web3": "^4.2.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "winston": "^3.11.0",
    "dotenv": "^16.3.1",
    "axios": "^1.6.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.54.0",
    "@truffle/hdwallet-provider": "^2.1.15",
    "solc": "^0.8.19"
  },
  "keywords": [
    "blockchain",
    "birth-certificate",
    "ethereum",
    "smart-contract",
    "microservice"
  ],
  "author": "E-Sant√© Team",
  "license": "MIT"
}

---

# services/naissance/.env.example
NODE_ENV=development
PORT=3001
ETHEREUM_PROVIDER=ws://localhost:8545
CONTRACT_ADDRESS=
LOG_LEVEL=info
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3002

# Deployment settings
PRIVATE_KEY=
INFURA_PROJECT_ID=
NETWORK=development

# Optional: IPFS settings
IPFS_URL=https://ipfs.infura.io:5001

---

# Truffle Configuration
# services/naissance/truffle-config.js
const HDWalletProvider = require('@truffle/hdwallet-provider');
require('dotenv').config();

module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 8545,
      network_id: "*",
      gas: 6721975,
      gasPrice: 20000000000
    },
    ganache: {
      host: "ganache",
      port: 8545,
      network_id: 1337,
      gas: 6721975,
      gasPrice: 20000000000
    },
    goerli: {
      provider: () => new HDWalletProvider(
        process.env.PRIVATE_KEY,
        `https://goerli.infura.io/v3/${process.env.INFURA_PROJECT_ID}`
      ),
      network_id: 5,
      gas: 5500000,
      confirmations: 2,
      timeoutBlocks: 200,
      skipDryRun: true
    },
    mainnet: {
      provider: () => new HDWalletProvider(
        process.env.PRIVATE_KEY,
        `https://mainnet.infura.io/v3/${process.env.INFURA_PROJECT_ID}`
      ),
      network_id: 1,
      gas: 5500000,
      gasPrice: 20000000000,
      confirmations: 2,
      timeoutBlocks: 200,
      skipDryRun: true
    }
  },
  mocha: {
    timeout: 100000
  },
  compilers: {
    solc: {
      version: "0.8.19",
      settings: {
        optimizer: {
          enabled: true,
          runs: 200
        }
      }
    }
  },
  plugins: [
    'truffle-plugin-verify'
  ],
  api_keys: {
    etherscan: process.env.ETHERSCAN_API_KEY
  }
};

---

# Contract Deployment Script
# services/naissance/scripts/deploy-contract.js
const Web3 = require('web3');
const fs = require('fs');
const path = require('path');
const solc = require('solc');
require('dotenv').config();

class ContractDeployer {
    constructor() {
        this.web3 = new Web3(process.env.ETHEREUM_PROVIDER || 'ws://localhost:8545');
        this.contractSource = null;
        this.compiledContract = null;
        this.deployedContract = null;
    }

    async loadAndCompileContract() {
        try {
            // Load contract source
            const contractPath = path.join(__dirname, '../contracts/BirthCertificateRegistry.sol');
            this.contractSource = fs.readFileSync(contractPath, 'utf8');

            // Prepare input for Solidity compiler
            const input = {
                language: 'Solidity',
                sources: {
                    'BirthCertificateRegistry.sol': {
                        content: this.contractSource
                    }
                },
                settings: {
                    outputSelection: {
                        '*': {
                            '*': ['*']
                        }
                    }
                }
            };

            // Compile contract
            const output = JSON.parse(solc.compile(JSON.stringify(input)));

            if (output.errors) {
                output.errors.forEach(error => {
                    if (error.severity === 'error') {
                        throw new Error(`Compilation error: ${error.message}`);
                    }
                    console.warn(`Warning: ${error.message}`);
                });
            }

            this.compiledContract = output.contracts['BirthCertificateRegistry.sol']['BirthCertificateRegistry'];
            console.log('‚úÖ Contract compiled successfully');

        } catch (error) {
            console.error('‚ùå Contract compilation failed:', error);
            throw error;
        }
    }

    async deployContract() {
        try {
            const accounts = await this.web3.eth.getAccounts();
            const deployAccount = accounts[0];

            console.log(`üöÄ Deploying contract from account: ${deployAccount}`);

            // Get contract ABI and bytecode
            const abi = this.compiledContract.abi;
            const bytecode = this.compiledContract.evm.bytecode.object;

            // Create contract instance
            const contract = new this.web3.eth.Contract(abi);

            // Estimate gas
            const gasEstimate = await contract.deploy({
                data: '0x' + bytecode
            }).estimateGas({ from: deployAccount });

            console.log(`‚õΩ Estimated gas: ${gasEstimate}`);

            // Deploy contract
            this.deployedContract = await contract.deploy({
                data: '0x' + bytecode
            }).send({
                from: deployAccount,
                gas: Math.floor(gasEstimate * 1.2),
                gasPrice: await this.web3.eth.getGasPrice()
            });

            console.log(`‚úÖ Contract deployed at address: ${this.deployedContract.options.address}`);

            // Save contract info
            await this.saveContractInfo(abi, this.deployedContract.options.address);

            return this.deployedContract.options.address;

        } catch (error) {
            console.error('‚ùå Contract deployment failed:', error);
            throw error;
        }
    }

    async saveContractInfo(abi, address) {
        const contractInfo = {
            address: address,
            abi: abi,
            deployedAt: new Date().toISOString(),
            network: process.env.NETWORK || 'development'
        };

        // Save to contract-info.json
        const infoPath = path.join(__dirname, '../contract-info.json');
        fs.writeFileSync(infoPath, JSON.stringify(contractInfo, null, 2));

        // Update .env file with contract address
        const envPath = path.join(__dirname, '../.env');
        let envContent = '';
        
        if (fs.existsSync(envPath)) {
            envContent = fs.readFileSync(envPath, 'utf8');
        }

        // Update or add CONTRACT_ADDRESS
        if (envContent.includes('CONTRACT_ADDRESS=')) {
            envContent = envContent.replace(/CONTRACT_ADDRESS=.*/, `CONTRACT_ADDRESS=${address}`);
        } else {
            envContent += `\nCONTRAC_ADDRESS=${address}\n`;
        }

        fs.writeFileSync(envPath, envContent);

        console.log('üíæ Contract info saved to contract-info.json and .env updated');
    }

    async run() {
        try {
            console.log('üèóÔ∏è  Starting contract deployment...');
            await this.loadAndCompileContract();
            const address = await this.deployContract();
            console.log(`üéâ Deployment completed! Contract address: ${address}`);
            return address;
        } catch (error) {
            console.error('üí• Deployment failed:', error);
            process.exit(1);
        }
    }
}

// Run deployment if called directly
if (require.main === module) {
    const deployer = new ContractDeployer();
    deployer.run();
}

module.exports = ContractDeployer;
